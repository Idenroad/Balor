#!/usr/bin/env bash
set -Eeuo pipefail

# Require Bash
if [ -z "${BASH_VERSION-}" ]; then
    cat >&2 <<'EOF'
This script requires Bash. Run it with:
    bash stacks/webexploit/commands.sh
or make it executable and run:
    ./stacks/webexploit/commands.sh
EOF
    exit 1
fi

# WebExploit Stack - Menu de Pentesting
# Outils: gobuster, sqlmap, hydra, nikto, whatweb, csrf-brute, ffuf, wpscan
: "${BALORSH_DATA_DIR:=/opt/balorsh/data}"
ensure_stack_data_dir "webexploit" || true
WEBEXPLOIT_LOG_ROOT="${BALORSH_DATA_DIR%/}/webexploit"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
make_log_dir() {
    local tool="$1"
    local dir="$WEBEXPLOIT_LOG_ROOT/$tool"
    if [[ ! -d "$dir" ]]; then
        if ! mkdir -p "$dir" 2>/dev/null; then
            sudo mkdir -p "$dir" || true
        fi
    fi
    if ! chmod 775 "$dir" 2>/dev/null; then
        sudo chmod 775 "$dir" || true
    fi
    local owner="${SUDO_USER:-$USER}"
    if ! chown "$owner:$owner" "$dir" 2>/dev/null; then
        sudo chown "$owner:$owner" "$dir" || true
    fi
    printf "%s" "$dir"
}
# shellcheck source=../../lib/common.sh
source "$ROOT_DIR/lib/common.sh"

# Helper: run a command, tee output to session_log, handle Ctrl-C, create cleaned .txt and wait for Enter
run_and_save_log() {
    local session_log="$1"
    shift
    set +e
    local child_pid=0
    local clean_log="${session_log%.log}.txt"
    handle_interrupt() {
        if [ "$child_pid" -ne 0 ]; then
            kill -INT "$child_pid" 2>/dev/null || true
        fi
        tr -cd '\11\12\15\40-\176' < "$session_log" > "$clean_log" 2>/dev/null || true
        echo "[Log saved] $session_log and $clean_log"
        trap - INT
        if [ -z "${NO_PROMPT-}" ]; then
            read -p "${WEBEXPLOIT_PRESS_ENTER}"
        fi
        return
    }
    trap 'handle_interrupt' INT

    "$@" 2>&1 | tee -a "$session_log" &
    local child_pid=$!
    wait $child_pid
    local status=$?
    trap - INT
    tr -cd '\11\12\15\40-\176' < "$session_log" > "$clean_log" 2>/dev/null || true
    set -e
    if [ $status -ne 0 ]; then
        echo "[command] exited with status $status."
    fi
    echo "[Log saved] $session_log and $clean_log"
    if [ -z "${NO_PROMPT-}" ]; then
        read -p "${WEBEXPLOIT_PRESS_ENTER}"
    fi
}

# Map old local names to the shared palette for compatibility
MAGENTA=${MAGENTA:-${C_ACCENT2:-$C_ACCENT1}}
NC=${NC:-$C_RESET}
GREEN=${GREEN:-${C_GOOD}}
BLUE=${BLUE:-${C_ACCENT2:-$C_ACCENT1}}
CYAN=${CYAN:-${C_INFO}}
YELLOW=${YELLOW:-${C_YELLOW}}
RED=${RED:-${C_RED}}

# Note: WEBEXPLOIT_* i18n strings are centralized in lib/lang/*.sh

show_menu() {
    # Use the same presentation style as other stacks (accent borders, highlight numbers)
    echo ""
    echo -e "${C_ACCENT2}═══════════════════════════════════════════════════════════════════${C_RESET}"
    echo -e "  ${C_HIGHLIGHT}${WEBEXPLOIT_MENU_TITLE}${C_RESET}"
    echo -e "${C_ACCENT2}═══════════════════════════════════════════════════════════════════${C_RESET}"
    echo ""
    echo -e " ${C_SHADOW}${WEBEXPLOIT_MENU_SECTION_RECON}${C_RESET}"
    echo -e " ${C_HIGHLIGHT}1)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_1}${C_RESET}"
    echo -e " ${C_HIGHLIGHT}2)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_2}${C_RESET}"
    echo -e " ${C_HIGHLIGHT}3)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_3}${C_RESET}"
    echo -e " ${C_HIGHLIGHT}4)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_4}${C_RESET}"
    echo ""
    echo -e " ${C_SHADOW}${WEBEXPLOIT_MENU_SECTION_FINGERPRINTING}${C_RESET}"
    echo -e " ${C_HIGHLIGHT}5)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_5}${C_RESET}"
    echo -e " ${C_HIGHLIGHT}6)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_6}${C_RESET}"
    echo ""
    echo -e " ${C_SHADOW}${WEBEXPLOIT_MENU_SECTION_FUZZING}${C_RESET}"
    echo -e " ${C_HIGHLIGHT}7)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_7}${C_RESET}"
    echo -e " ${C_HIGHLIGHT}8)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_8}${C_RESET}"
    echo ""
    echo -e " ${C_SHADOW}${WEBEXPLOIT_MENU_SECTION_GROUPED}${C_RESET}"
    echo -e " ${C_YELLOW}9)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_9}${C_RESET}"
    echo ""
    echo -e " ${C_HIGHLIGHT}0)${C_RESET} ${C_INFO}${WEBEXPLOIT_MENU_0}${C_RESET}"
    echo ""
    echo -e "${C_ACCENT2}═══════════════════════════════════════════════════════════════════${C_RESET}"
    echo ""

}
run_gobuster() {
    echo -e "${MAGENTA}${WEBEXPLOIT_GOBUSTER_TITLE}${NC}"
    read -p "${WEBEXPLOIT_GOBUSTER_TARGET}" target
    read -p "${WEBEXPLOIT_GOBUSTER_WORDLIST}" wordlist
    local wordlist=${wordlist:-/usr/share/wordlists/dirb/common.txt}
    read -p "${WEBEXPLOIT_GOBUSTER_EXTENSIONS}" extensions

    # Ask whether to run discover-backup (optional)
    read -p "Découvrir extensions de sauvegarde ? (o/N) : " backup_choice
    if [[ "$backup_choice" =~ ^[oOyY] ]]; then
        local discover_flag="--discover-backup"
    else
        local discover_flag=""
    fi

    # Ask TLS validation (default NO). If user does not confirm, disable TLS validation.
    read -p "${WEBEXPLOIT_GOBUSTER_TLS_PROMPT}" tls_choice
    if [[ "$tls_choice" =~ ^[oOyY] ]]; then
        local tls_flag=""
    else
        local tls_flag="--no-tls-validation"
    fi

    # Ask for exclude-length values (comma separated). Ignore lengths 101 and 302.
    read -p "${WEBEXPLOIT_GOBUSTER_EXCLUDE_LENGTH}" exclude_lengths_raw
    local exclude_lengths_raw=${exclude_lengths_raw// /,}
    local exclude_value=""
    if [ -n "$exclude_lengths_raw" ]; then
        IFS=',' read -ra parts <<< "$exclude_lengths_raw"
        local filtered=""
        for p in "${parts[@]}"; do
            local p_clean=$(echo "$p" | tr -dc '0-9')
            if [ -z "$p_clean" ]; then
                continue
            fi
            if [ -z "$filtered" ]; then
                filtered="$p_clean"
            else
                filtered="$filtered,$p_clean"
            fi
        done
        if [ -n "$filtered" ]; then
            exclude_value="$filtered"
        fi
    fi

    # prepare gobuster-specific log dir and files under /opt/balorsh/data/gobuster
    gobuster_log_root="${BALORSH_DATA_DIR%/}/gobuster"
    if [[ ! -d "$gobuster_log_root" ]]; then
        if ! mkdir -p "$gobuster_log_root" 2>/dev/null; then
            sudo mkdir -p "$gobuster_log_root" || true
        fi
    fi
    if ! chmod 775 "$gobuster_log_root" 2>/dev/null; then
        sudo chmod 775 "$gobuster_log_root" || true
    fi
    owner="${SUDO_USER:-$USER}"
    if ! chown "$owner:$owner" "$gobuster_log_root" 2>/dev/null; then
        sudo chown "$owner:$owner" "$gobuster_log_root" || true
    fi

    safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
    timestamp=$(date +%Y%m%d_%H%M%S)
    raw_log="$gobuster_log_root/session_gobuster_${safe_target}_${timestamp}.log"
    clean_log="$gobuster_log_root/session_gobuster_${safe_target}_${timestamp}.txt"

    # Build command as array to avoid word-splitting issues and show it to the user
    cmd=(gobuster dir -u "$target")
    # include discover-backup if requested
    if [ -n "$discover_flag" ]; then
        cmd+=("$discover_flag")
    fi
    # use -k to skip TLS validation when user declined validation
    if [[ "$tls_flag" != "" ]]; then
        # previous value was like --no-tls-validation; map to -k for gobuster
        cmd+=("-k")
    fi
    if [ -n "$exclude_value" ]; then
        cmd+=("--exclude-length" "$exclude_value")
    fi
    if [ -z "$extensions" ]; then
        cmd+=("-w" "$wordlist" "-t" "50")
    else
        cmd+=("-w" "$wordlist" "-x" "$extensions" "-t" "50")
    fi

    echo "[Command] ${cmd[*]}"
    read -p "Confirmer exécution ? (o/N) : " confirm
    if [[ ! "$confirm" =~ ^[oOyY] ]]; then
        echo "Annulé. Retour au menu."
        read -p "${WEBEXPLOIT_PRESS_ENTER}"
        return
    fi

    # Run gobuster but avoid script exit on non-zero return (temporarily disable -e)
    set +e
    child_pid=0
    interrupted=0
    handle_interrupt() {
        interrupted=1
        if [ "$child_pid" -ne 0 ]; then
            kill -INT "$child_pid" 2>/dev/null || true
        fi
        # Ensure cleaned log exists from whatever was captured so far
        tr -cd '\11\12\15\40-\176' < "$raw_log" > "$clean_log" 2>/dev/null || true
        echo "[Log saved] $raw_log and $clean_log"
        # restore default trap
        trap - INT
        read -p "${WEBEXPLOIT_PRESS_ENTER}"
        return
    }
    trap 'handle_interrupt' INT

    # Start gobuster in background with tee so live output is shown and written to raw_log
    "${cmd[@]}" 2>&1 | tee -a "$raw_log" &
    child_pid=$!
    wait $child_pid
    status=$?

    # cleanup trap
    trap - INT
    # Create cleaned log from raw log so full output is shown live
    tr -cd '\11\12\15\40-\176' < "$raw_log" > "$clean_log" || true
    set -e

    if [ $status -ne 0 ]; then
        echo "[gobuster] exited with status $status."
    fi

    echo "[Log saved] $raw_log and $clean_log"
    read -p "${WEBEXPLOIT_PRESS_ENTER}"
}



run_sqlmap() {
    echo -e "${MAGENTA}${WEBEXPLOIT_SQLMAP_TITLE}${NC}"
    read -p "${WEBEXPLOIT_GOBUSTER_TARGET}" target

    # Ask whether target is IP or URL. If IP, prompt for vhost and run gobuster vhost mode.
    read -p "${WEBEXPLOIT_TARGET_TYPE_PROMPT}" type_choice
    type_choice=${type_choice:-URL}
    if [[ "$type_choice" =~ ^[Ii][Pp]$ ]]; then
        # IP target: ask for vhost and run vhost mode
        read -p "${WEBEXPLOIT_VHOST_PROMPT}" vhost
        read -p "${WEBEXPLOIT_GOBUSTER_WORDLIST}" wordlist
        wordlist=${wordlist:-/usr/share/wordlists/dirb/common.txt}
        read -p "${WEBEXPLOIT_GOBUSTER_EXTENSIONS}" extensions

        # Ask TLS validation (default NO). If user does not confirm, disable TLS validation.
        read -p "${WEBEXPLOIT_GOBUSTER_TLS_PROMPT}" tls_choice
        if [[ "$tls_choice" =~ ^[oOyY] ]]; then
            tls_flag=""
        else
            tls_flag="--no-tls-validation"
        fi

        # prepare log dir and file
        log_dir=$(make_log_dir gobuster)
        safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
        session_log="$log_dir/session_gobuster_vhost_${safe_target}_$(date +%Y%m%d_%H%M%S).log"

        if [ -z "$extensions" ]; then
            run_and_save_log "$session_log" gobuster vhost -u "$target" $tls_flag -H "Host: $vhost" -w "$wordlist" -t 50
        else
            run_and_save_log "$session_log" gobuster vhost -u "$target" $tls_flag -H "Host: $vhost" -w "$wordlist" -x "$extensions" -t 50
        fi
        return
    fi

    # URL target: proceed as before
    read -p "${WEBEXPLOIT_GOBUSTER_WORDLIST}" wordlist
    wordlist=${wordlist:-/usr/share/wordlists/dirb/common.txt}
    read -p "${WEBEXPLOIT_GOBUSTER_EXTENSIONS}" extensions

    # Ask TLS validation (default NO). If user does not confirm, disable TLS validation.
    read -p "${WEBEXPLOIT_GOBUSTER_TLS_PROMPT}" tls_choice
    if [[ "$tls_choice" =~ ^[oOyY] ]]; then
        tls_flag=""
    else
        tls_flag="--no-tls-validation"
    fi

    # prepare log dir and file
    log_dir=$(make_log_dir gobuster)
    safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
    session_log="$log_dir/session_gobuster_${safe_target}_$(date +%Y%m%d_%H%M%S).log"

    if [ -z "$extensions" ]; then
        run_and_save_log "$session_log" gobuster dir -u "$target" $tls_flag -w "$wordlist" -t 50
    else
        run_and_save_log "$session_log" gobuster dir -u "$target" $tls_flag -w "$wordlist" -x "$extensions" -t 50
    fi
}

run_hydra() {
    echo -e "${MAGENTA}${WEBEXPLOIT_HYDRA_TITLE}${NC}"
    read -p "${WEBEXPLOIT_HYDRA_TARGET}" target
    echo ""
    echo "${WEBEXPLOIT_HYDRA_SERVICE}"
    echo "[1] ${WEBEXPLOIT_HYDRA_SERVICE_1}"
    echo "[2] ${WEBEXPLOIT_HYDRA_SERVICE_2}"
    echo "[3] ${WEBEXPLOIT_HYDRA_SERVICE_3}"
    read -p "${WEBEXPLOIT_SQLMAP_CHOICE}" service
    
    read -p "${WEBEXPLOIT_HYDRA_USER}" user
    read -p "${WEBEXPLOIT_HYDRA_PASSLIST}" passlist
    
    # prepare log dir
    log_dir=$(make_log_dir hydra)
    safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
    session_log="$log_dir/session_hydra_${safe_target}_$(date +%Y%m%d_%H%M%S).log"

    case $service in
        1)
            run_and_save_log "$session_log" hydra -l "$user" -P "$passlist" ssh://"$target"
            ;;
        2)
            run_and_save_log "$session_log" hydra -l "$user" -P "$passlist" ftp://"$target"
            ;;
        3)
            read -p "${WEBEXPLOIT_HYDRA_PATH}" path
            read -p "${WEBEXPLOIT_HYDRA_POSTDATA}" postdata
            read -p "${WEBEXPLOIT_HYDRA_FAILSTRING}" failstring
            run_and_save_log "$session_log" hydra -l "$user" -P "$passlist" "$target" http-post-form "$path:$postdata:$failstring"
            ;;
    esac

    echo "[Log saved] $session_log"
    read -p "${WEBEXPLOIT_PRESS_ENTER}"
}

run_nikto() {
    echo -e "${MAGENTA}${WEBEXPLOIT_NIKTO_TITLE}${NC}"
    read -p "${WEBEXPLOIT_NIKTO_TARGET}" target
    log_dir=$(make_log_dir nikto)
    safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
    session_log="$log_dir/session_nikto_${safe_target}_$(date +%Y%m%d_%H%M%S).log"
    run_and_save_log "$session_log" nikto -h "$target" -C all
}

run_whatweb() {
    echo -e "${MAGENTA}${WEBEXPLOIT_WHATWEB_TITLE}${NC}"
    read -p "${WEBEXPLOIT_WHATWEB_TARGET}" target
    log_dir=$(make_log_dir whatweb)
    safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
    session_log="$log_dir/session_whatweb_${safe_target}_$(date +%Y%m%d_%H%M%S).log"
    run_and_save_log "$session_log" whatweb -v -a 3 "$target"
}

run_wpscan() {
    echo -e "${MAGENTA}${WEBEXPLOIT_WPSCAN_TITLE}${NC}"
    read -p "${WEBEXPLOIT_WPSCAN_TARGET}" target
    echo ""
    echo "${WEBEXPLOIT_WPSCAN_OPTIONS}"
    echo "[1] ${WEBEXPLOIT_WPSCAN_OPTION_1}"
    echo "[2] ${WEBEXPLOIT_WPSCAN_OPTION_2}"
    echo "[3] ${WEBEXPLOIT_WPSCAN_OPTION_3}"
    echo "[4] ${WEBEXPLOIT_WPSCAN_OPTION_4}"
    read -p "${WEBEXPLOIT_WPSCAN_CHOICE}" choice
    log_dir=$(make_log_dir wpscan)
    safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
    session_log="$log_dir/session_wpscan_${safe_target}_$(date +%Y%m%d_%H%M%S).log"

    case $choice in
        1)
            wpscan --url "$target" 2>&1 | tee -a "$session_log"
            ;;
        2)
            wpscan --url "$target" --enumerate u 2>&1 | tee -a "$session_log"
            ;;
        3)
            wpscan --url "$target" --enumerate vp 2>&1 | tee -a "$session_log"
            ;;
        4)
            read -p "${WEBEXPLOIT_WPSCAN_USER}" user
            read -p "${WEBEXPLOIT_WPSCAN_WORDLIST}" wordlist
            wpscan --url "$target" -U "$user" -P "$wordlist" 2>&1 | tee -a "$session_log"
            ;;
    esac

    echo "[Log saved] $session_log"
    read -p "${WEBEXPLOIT_PRESS_ENTER}"
}

run_ffuf() {
    echo -e "${MAGENTA}${WEBEXPLOIT_FFUF_TITLE}${NC}"
    read -p "${WEBEXPLOIT_FFUF_TARGET}" target
    # Allow the user to paste a full ffuf command line to run exactly as-is
    read -p "${WEBEXPLOIT_FFUF_CMDLINE}" ffuf_cmdline
    # default wordlist via i18n prompt
    read -p "${WEBEXPLOIT_FFUF_WORDLIST}" wordlist
    wordlist=${wordlist:-/usr/share/wordlists/wfuzz/general/common.txt}
    log_dir=$(make_log_dir ffuf)
    safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
    session_log="$log_dir/session_ffuf_${safe_target}_$(date +%Y%m%d_%H%M%S).log"
    if [ -n "$ffuf_cmdline" ]; then
        echo "[Info] Exécution de la ligne fournie : $ffuf_cmdline"
        run_and_save_log "$session_log" bash -lc "$ffuf_cmdline"
        return
    fi

    # Ensure FUZZ placeholder exists in URL — append /FUZZ if missing
    if [[ "$target" != *FUZZ* ]]; then
        if [[ "$target" == */ ]]; then
            target="${target}FUZZ"
        else
            target="${target%/}/FUZZ"
        fi
        echo "[Info] Aucun 'FUZZ' détecté — utilisation : $target"
    fi

    # Run ffuf (no color flag) with chosen wordlist
    run_and_save_log "$session_log" ffuf -u "$target" -w "$wordlist" -t 50
}

run_csrf_brute() {
    echo -e "${MAGENTA}${WEBEXPLOIT_CSRF_TITLE}${NC}"
    read -p "${WEBEXPLOIT_CSRF_TARGET}" target
    read -p "${WEBEXPLOIT_CSRF_LOGIN}" login
    read -p "${WEBEXPLOIT_CSRF_WORDLIST}" wordlist
    wordlist=${wordlist:-/usr/share/wordlists/seclists/Passwords/Leaked-Databases/md5decryptor-uk.txt}
    log_dir=$(make_log_dir csrf)
    safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
    session_log="$log_dir/session_csrf_${safe_target}_$(date +%Y%m%d_%H%M%S).log"

    run_and_save_log "$session_log" csrf-brute -u "$target" -l "$login" -P "$wordlist"
}

run_full_recon() {
    echo -e "${MAGENTA}${WEBEXPLOIT_FULL_RECON_TITLE}${NC}"
    read -p "${WEBEXPLOIT_FULL_RECON_TARGET}" target
    log_dir=$(make_log_dir full_recon)
    safe_target=$(echo "$target" | sed 's|[^A-Za-z0-9._-]|_|g')
    session_log="$log_dir/session_fullrecon_${safe_target}_$(date +%Y%m%d_%H%M%S).log"

    echo -e "${YELLOW}${WEBEXPLOIT_FULL_RECON_STEP1}${NC}"
    NO_PROMPT=1 run_and_save_log "$session_log" whatweb -v -a 3 "$target"

    echo ""
    echo -e "${YELLOW}${WEBEXPLOIT_FULL_RECON_STEP2}${NC}"
    NO_PROMPT=1 run_and_save_log "$session_log" nikto -h "$target" -C all

    echo ""
    echo -e "${YELLOW}${WEBEXPLOIT_FULL_RECON_STEP3}${NC}"
    NO_PROMPT=1 run_and_save_log "$session_log" gobuster dir -u "$target" -w /usr/share/wordlists/dirb/common.txt -t 50

    echo ""
    echo -e "${GREEN}${WEBEXPLOIT_FULL_RECON_COMPLETE}${NC}"
    read -p "${WEBEXPLOIT_PRESS_ENTER}"
}

# Boucle principale
while true; do
    show_menu
    read -p "${WEBEXPLOIT_CHOICE_PROMPT}" choice
    
    case $choice in
        1) run_gobuster ;;
        2) run_sqlmap ;;
        3) run_hydra ;;
        4) run_nikto ;;
        5) run_whatweb ;;
        6) run_wpscan ;;
        7) run_ffuf ;;
        8) run_csrf_brute ;;
        9) run_full_recon ;;
        
        0) 
            echo -e "${C_GOOD}${WEBEXPLOIT_GOODBYE}${NC}"
            exit 0
            ;;
        *)
            echo -e "${C_RED}${WEBEXPLOIT_INVALID_CHOICE}${NC}"
            sleep 2
            ;;
    esac
done